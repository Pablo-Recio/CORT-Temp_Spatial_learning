---
title: "Prenatal conditions do not affect brain physiology and learning in a lizard"
docx: 
bibliography: "./bib/refs.bib"
csl: "./bib/biology-letters.csl"
reference-doc: "./bib/tmpl.docx"
execute:
  echo: false
  error: false
  cache: false
  warning: false
link-citations: true
crossref:  
  fig-title: Figure    # (default is "Figure")
  title-delim: —     # (default is ":")
  fig-prefix: Figure   # (default is "Figure")
  tbl-prefix: Table  # (default is "Table")
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
pacman::p_load(tidyverse, flextable, emmeans, DHARMa, brms, here, ggplot2, lme4, zoo, lmerTest, broom, tidybayes, ggh4x, cowplot, fitdistrplus, MASS, goftest, forcats, nortest, fitdistrplus, ggh4x, PupillometryR, png, grid, remotes, ggthemes, bayestestR, HDInterval, DiagrammeR, magick)
```

```{r, data_processing}
#| label: data_processing
# The result will be the final df with the data for the analysis. To do so, we first estimate the learning slope (choice and errors) for each individual and then merge the data with the mitochondrial data, extracted using the script in extract.R and extraction_finc.R (see R folder). The final df will be saved in (here("output/databases_clean/data_complete.csv") 
refit <- FALSE
source(here("R", "data_process.R"))
```

```{r, data_metrics}
#| label: data_metrics
# Using the raw learning database, I calculate here some basic metrics mentioned later in the Methdos (see below).
data <- read.csv(here("./data/Spatial_learn.csv"))
#
# Total number of clutches
total_clutches <- data %>% 
  distinct(clutch) %>% 
  count() %>% 
  pull(n)
# Calculate total number of individuals
total_individuals <- data %>% 
  distinct(lizard_id) %>% 
  count() %>% 
  pull(n)
# Calculate number of individuals per clutch
individuals_per_clutch <- data %>%
  distinct(lizard_id, clutch) %>%
  group_by(clutch) %>%
  summarize(individual_count = n())
```

```{r, sampleSize}
#| label: sampleSize
# List with the sample sizes from the main database.
source(here("R", "func.R"))
#
hormone <- c("CORT", "Control")
temperature <- c("Cold", "Hot")
#
n_list <- list()
#
for(k in 1:length(hormone)){
  for(l in 1:length(temperature)){
    list_name <- paste0(hormone[k], "_", temperature[l])
    n_list[[list_name]] <- sample(df = clean_df, corti = hormone[k], therm = temperature[l])
  }
}
#
df_damage <- clean_df %>%
  filter(DNAdamage != "NA")
n_damage <- list()
for(k in 1:length(hormone)){
  for(l in 1:length(temperature)){
    list_name <- paste0(hormone[k], "_", temperature[l])
    n_damage[[list_name]] <- sample(df = df_damage, corti = hormone[k], therm = temperature[l])
  }
}
```

Pablo Recio^1^,$\ddagger$ , Dalton C. Leibold^1^, Ondi L. Crino ^1,2^, Christopher R. Friesen^3^, Daniel W.A. Noble^1^

^1^ Division of Ecology and Evolution, Research School of Biology, The Australian National University, Canberra, ACT 2601, Australia  
^2^ Flinder's University, College of Science and Engineering, Bedford Park, SA 5042, Australia  
^3^ University of Wollongong, Wollongong, NSW 2500, Australia  
$\ddagger$ Corresponding author: pablo.reciosantiago@anu.edu.au  

ORCID: 

Pablo Recio ORCID: 0000-0002-5890-0218  
Dalton C. Leibold ORCID: 0000-0001-9645-2033  
Ondi L. Crino ORCID: 0000-0001-5700-1387  
Christopher R. Friesen ORCID: 0000-0001-5338-7454  
Daniel W.A. Noble ORCID: 0000-0001-9460-8743  


```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

## Abstract
Early environmental factors like heat or stress hormones can impair learning through brain metabolic function, crucial for neural development and synaptic plasticity. However, whether early environments always result in cognitive impairment through changes in neural physiology is not well-established outside of a few model systems. Here, we investigated the effects of prenatal temperature and corticosterone (CORT) on brain mitochondrial activity and spatial learning in the delicate skink (_Lampropholis delicata_). We treated eggs with either CORT or a control vehicle and incubated at cold (23 ± 3°C) or hot (28 ± 3°C) temperatures. Juveniles were tested in a spatial learning task over 40 days after which mitochondrial function in the medial cortex was assessed. Despite among-individual variation in learning ability, mitochondrial physiology and spatial learning in _L. delicata_ remained robust to prenatal temperature and CORT exposure. No significant relationship was found between mitochondrial function and cognitive performance, contrary to predictions. Additionally, increased metabolic capacity correlated with higher ROS production but did not affect oxidative damage, possibly due to protective mechanisms. These findings highlight the physiological and cognitive resilience of _L. delicata_ to early-life challenges. Future research should explore whether this robustness extends to other brain regions, cognitive domains, and life stages.   

## Introduction

Learning - the acquisition and consolidation of new information [@dukas_evolutionary_2004] - enables animals to create new associations between events, which can be essential for coping with environmental change [@dukas_evolutionary_2004; @leal_behavioural_2012; @buchanan_condition_2013]. However, the capacity to form these associations varies among individuals, potentially affecting their responses to environmental challenges [@ward2016ecological; @welklin2024spatial]. Learning faster may imply exploiting novel resources better or responding to new threats more efficiently [@ward2016ecological]. Consequently, individual differences in learning abilities can have profound effects on fitness, ultimately influencing population growth rates and stability [@ward2016ecological; @welklin2024spatial]. Understanding the mechanisms that drive these differences is therefore crucial for predicting how populations will respond to novel conditions.  

Factors like age, sex, or early-life conditions can have important effects on learning abilities [@szuran_water_1994; @lemaire_prenatal_2000; @zhu_prenatal_2004; @amiel_hotter_2012; @amiel_egg_2014; @carazo_sex_2014; @noble_age-dependent_2014]. Adverse developmental environments are particularly influential, as the brain is highly sensitive to environmental inputs during early life [@zhu_prenatal_2004]. In fact, early experiences can alter neurotransmitter production [@amani2021perinatal], gene expression [@zhou2020effects], or brain structure [@amiel_effects_2017], with lasting effects on cognition. Among the physiological mechanisms underlying learning, mitochondrial activity is considered a key factor [@siegel1994basic; @du_dynamic_2009; @picard_mitochondria_2014; @picard_energetic_2018]. The neural processes involved in learning impose substantial energetic demands [@mcnay_decreases_2000; @mann_coupling_2021; @alexandrov_neuronal_2022], making efficient mitochondrial respiration essential [@du_dynamic_2009; @picard_mitochondria_2014; @picard_energetic_2018]. Additionally, learning depends on a dense network of functional neurons [@lefebvre_taxonomic_2011; @amiel_effects_2017], which can be compromised by excessive oxidative stress - a byproduct of mitochondrial metabolism [@finkel_oxidants_2000; @zhu_prenatal_2004; @du_dynamic_2009; @gong_chronic_2011; @hoffmann_mitochondrion_2018]. Studies on mammals have shown the pervasive effects of mitochondrial physiology on cognitive abilities [@zhu_prenatal_2004; @hara_presynaptic_2014; @cao2014ampk]. However, the extent to which these effects are generalizable to other taxa remains largely unexplored.     

Since mitochondria are maternally inherited, maternal condition plays a fundamental role in shaping offspring mitochondrial activity [@picard_mitochondria_2014]. Maternal stress can also influence how mitochondria operate in offspring [@zhu_prenatal_2004]. Stressful situations experienced by mothers can elevate glucocorticoids (GCs) [@sapolsky_how_2000], which can be transmitted to the developing embryos [@uller_sex-specific_2009] altering mitochondrial physiology through transgenerational effects [@picard_mitochondria_2014]. For instance, maternal stress has been shown to contribute significantly to oxidative stress in the brain of rats (_Rattus norvegicus_) with impacts on spatial learning abilities [@zhu_prenatal_2004; @haussmann_embryonic_2012; @cao2014ampk].  

Temperature is also a significant source of maternal stress in ectotherms. Thermal environments outside of the optimal range can elevate GCs in mothers, which can be passed to the offspring [see @Crino_2023]. Additionally, temperature can also directly influence offspring development, particularly during early life [@noble_developmental_2018; @crino2024eggs]. The prenatal thermal environment plays a crucial role in shaping mitochondrial function, affecting energy metabolism and oxidative stress [@stier2022experimental; @crino2024eggs]. Thus, the combined effects of prenatal GCs and temperature may profoundly influence mitochondrial function, with important consequences for brain development and cognition. However, the extent to which prenatal GCs and temperature interact to shape cognitive abilities via mitochondrial physiology remains largely unknown outside of a few model species [@zhu_prenatal_2004; @haussmann_embryonic_2012; @cao2014ampk].  

Here, we examined how prenatal temperature and corticosterone (CORT) — the primary GC in reptiles — affect brain mitochondrial physiology and spatial learning in the delicate skink (_Lampropholis delicata_). We hypothesized that prenatal CORT and temperature would influence learning abilities through impacts on brain mitochondrial activity. Specifically, we predicted that prenatal CORT would decrease energy production while increasing oxidative damage [@costantini2011meta; @gong_chronic_2011; but see @crino2024eggs], especially if CORT can alter cellular components increasing ROS production without enhancing ATP synthesis or making them more vulnerable to oxidative damage. Similarly, high temperatures would decrease mitochondrial efficiency [@zavorka_climate_2021; @crino2024eggs], but with the potential to reduce oxidative stress [@treidel2016temperature]. We further predicted that the combined effects of CORT and temperature would lead to complex interactions, with both factors negatively impacting mitochondrial efficiency but having opposite effects on oxidative stress. These effects would lead to differences in learning abilities, that could be affected by the balance between energy production and oxidative stress [@du_dynamic_2009; @picard_energetic_2018; @alexandrov_neuronal_2022]. By examining these interactions, we aim to clarify how prenatal environmental factors shape learning abilities through mitochondrial function, shedding light on the role of early-life conditions in cognitive development and associated mechanismsm.  

## Methods  

#### Experimental animals
Lizards came from a breeding colony established in the laboratory in 2019 from wild populations in Sydney, Australia. The colony consisted of 270 adults living in groups of two males and four females. Eggs were collected from these groups between November 2023 to January 2024. After collecting the eggs, we treated them with CORT or a vehicle control and incubated them under two different temperature regimes (see below). Clutch and egg identity were assigned immediately after egg collection, and the eggs were incubated in individual cups until hatching. Hatchlings were also kept in individual enclosures until the end of the experiment. For details on husbandry and breeding conditions see _Methods 1: Animal husbandry in Supplementary Material_.
 
#### Corticosterone and temperature manipulations
We tested the combined effects of prenatal CORT and temperature by elevating CORT concentrations in eggs and then incubating them under one of two temperature regimes (Cold - 23 ± 3 ºC or Hot - 28 ± 3 ºC). We used a partial split clutch design where eggs from a given clutch were distributed equally across the four treatments when clutch sizes were larger than four and randomly across treatments when less than four. CORT-treated eggs were topically supplied with 5 µL of crystalline corticosterone (Sigma, Cat. No. C2505) dissolved in 100% ethanol at a final concentration of 10 pg CORT/mL (CORT treatment), while Control eggs received an equal volume of 100% Ethanol. CORT dose increased mean yolk CORT levels ~3.7x higher than control eggs in previous studies [@crino2024eggs]. Eggs were then incubated in one of the two previously mentioned temperature regimes that are within the natural limits of nest temperatures in _L. delicata_ [@cheetham2011embryonic].   

#### Spatial learning  
The spatial learning task involved training lizards to navigate a 6-arm maze to reach an exit connected to a transport box that allowed us to return the lizards to their enclosure without further contact. In each trial, lizards were placed by hand in the center of maze and left to acclimatise for two minutes. During acclimatisation, the central area was surrounded by a yellow device mounted on a pulley system. At the start of each trial, this device was lifted to startle the lizard. If the lizard did not immediately choose an arm, it was gently prodded with a brush at the end of the tail. Once the lizard made a choice, the brush was used to encourage movement but without guiding it towards any specific arm. If the lizard did not choose correctly after 20 errors — at which point it typically ceased responding — the lizard was gently guided to the correct arm.     

We assessed lizards' spatial learning using external cues for navigation while avoiding intra-maze cues. Subtle intra-maze cues were avoided by replacing the maze every three trials with one of four identical mazes. Each replacement preserved the correct arm’s orientation and the maze’s position within the room, ensuring consistency for each individual. Additionally, the maze was cleaned with 70% ethanol between trials to avoid the influence of chemical cues. To control for potential side biases, the correct arm was randomly assigned to one of the six arms for each trial. We employed four different maze orientations counterbalancing the number of lizards assigned to each orientation across treatments.  

The task was repeated once daily for 40 consecutive days, and the number of errors made by each lizard was recorded. An error was defined as the lizard inserting its head into one of the incorrect arms, choosing the same arm two or more times consecutively was counted as independent errors.   

#### Brain mitochondrial function
Immediately following the completion of the tests, we quantified mitochondrial physiology in the brain of lizards. We euthanized lizards via peritoneal injection 10 mg/kg of a 10 mg/mL alfaxan solution (a potent anesthetic), followed by decapitation. Before decapitation we evaluated lizard righting responses and the pinching reflexes in one of the front limbs.  

We extracted the medial cortex in the telencephalon as this brain region is considered homologous to the mammalian hippocampus, where spatial cognition is encoded [@rodríguez2002conservation; @naumann2015reptilian]. The tissue was transferred to 1X PBS solution and then homogenized mechanically using a 100 µm mesh filter (pluriStrainer). The resultant homogenate was divided into two aliquots: one was used fresh for measuring mitochondrial density, membrane potential - a metric of mitochondrial metabolic capacity [@martinez2016tca] - and superoxide (ROS) production; and the other was cryopreserved for later measurements of DNA damage and lipid peroxidation.  

Fresh homogenate suspensions were stained with 5 µM MitoTracker Deep Red FM, 2.5 µM MitoTracker Orange CMTMRos, and 50 µM MitoSOX Red. We used these fluorescent probes to assess mitochondrial density, membrane potential, and ROS, respectively. We also added 5 µL of 10 µg/mL Hoechst 33342 Nuclear Viability Dye to each sample to differentiate viable cells from debris. These samples were analyzed in a flow cytometer within 2 hours of brain extraction.  

The aliquots reserved for oxidative damage assays were stained with 20 µL of 10 µg/mL Hoechst 33342 Nuclear Viability Dye and 20 µL of 100 µM BODIPY 665/676 Lipid Peroxidation Sensor before cryopreservation. These dyes were used to measure cell viability and lipid peroxidation, respectively. The samples were then fixed in 1% Neutral-Buffered Formalin, washed, and preserved in a 1X Tris-EDTA solution with 10% DMSO at -20 °C. On the day of the oxidative damage assays, the samples were thawed, and DMSO was removed. Then, cell membranes were permeabilized in 200 µL of 1X PBS containing 5mM (6.14 mg/mL) digitonin. Following permeabilization we stained the samples with 20µL of 70µM 8-OHdG Polyclonal Antibody - a marker of DNA damage - and allowed them to incubate overnight (~12 hours). The following day we counterstained the cells with 20µL of 100 µg/mL H+G Goat Anti-Rabbit Conjugate Antibody with Alexa-Fluor 488 and analyzed the samples using the flow cytometer. Oxidative damage assays were performed within 6 months of the initial analysis of fresh samples.  

Flow cytometry was performed on a Becton Dickson LSRFortessa X-20 flow cytometer using the default wavelength filters. Detectors and voltage settings for each assay were determined during pilot trials and remained consistent throughout the experiment. Data was processed using FlowJo (v. 10.1) software. We obtained the mean fluorescent intensity for mitochondrial density, metabolic capacity, ROS, DNA damage, and lipid peroxidation. For further details on the homogenization, staining, or flow cytometry assays see _Methods 2: flow cytometry in Supplementary Material_. Sample sizes for DNA damage and lipid peroxidation were smaller than for the other variables because of a plater reader malfunction, however, data was missing randomly and we dealt with missing data in our analyses (see below).     

#### Statistical analyses
We performed all analyses using the _brm_ package [@burkner2017brms] which fits Bayesian multilevel models with Stan [@stan] with R version 4.4.0 [@R]. We ran a series of univariate and multivariate models to test the effects of early envinonment on each variable separately plus quantify the relationships between physiology and learning. All models consisted of four MCMC chains of 8000 iterations, with a warmup interval of 2000 iterations. 

Univariate models were used to test the effects of early environment on each of the variables recorded: mitochondrial density, metabolic capacity, ROS, DNA damage, lipid peroxidation, and the number of errors as a measure of learning. We included in all the models the hormone treatment (CORT vs Control), incubation temperature (Cold vs Hot) and their interaction. Sex and age were included in preliminary models and excluded from the final models when they were not significant. For all univariate models, clutch identity was included as a random factor. Mitochondrial related variables where log-transformed when necessary and all were mean-centered and standardized by dividing them by two times the standard deviation [@gelman2008scaling]. These variables were considered to follow a normal distribution. 

Learning was modeled as a function of trial, cort, temperature, and their three-way interaction. We included in this model the trial within each level of lizard identity as a random slope. The error structure was modelled using a negative binomial distribution with a logit link function [negbinomial(link = "log")]. Otherwise, the procedure was as in the other models.  

We used the posterior distributions of parameters from these models to test for differences between treatments. Learning slopes were obtained using the ‘trial’ estimates and its interaction with hormone and temperature treatments. Slope estimates less than 0 provide evidence of learning. _pMCMC_ was used to test the hypothesis that posterior distributions of slopes, and slope contrasts, were different from zero. We considered an effect statistically significant when _pMCMC_ <0.05.  

To explore direct and indirect links between mitochondrial function and learning, we fitted a multivariate structural equation model (SEM) using _brms_. The model was structured based on theoretical expectations shown in @fig-sem. Any missing data was imputed during model fitting using data augmentation [@noble2021planned], but this was largely restricted to DNA damage and lipid peroxidation. To obtain a measure of learning performance we extracted the posterior distribution of individual learning slopes (i.e., changes in error over time) for each lizard. This was achieved by including a random trial slope for each lizard. Learning slopes, as well as the rest of variables, were standardized as before (see above). We assumed a gaussian error distribution for all the variables in this model. Factors found as non-significant in the univariate models were excluded. Clutch identity remained a random factor in our SEM model. Direct, indirect, and total effects were derived from posterior estimates [@kline2005principles] (see table S4).  
  
## Results

We started with 80 lizards - 20 per treatment - coming from `r total_clutches` clutches. However, due to natural mortality, only 79 lizards were included in the learning analyses, and 78 in the mitochondrial analyses. We provide final sample sizes in all our figures.     

```{r, models_mitochondrial}
#| label: models_mitochondrial
# Fitting the model and extraction of posteriors for both types of task and species using fit_m function (see func.r in R folder). The result everytime the function is used is a df with the posteriors of the model. The functions saves the model automatically in output/models; and when the parameter refit = FALSE then the posteriors are extracted from the model previously written instead of fitting the model again each time.
source(here("R", "func.R"))
# 
#
# Run models mitochondrial physiology 
var_m <- c("mit_density", "mit_potential", "ROS", "DNAdamage", "peroxidation")
for (p in var_m){ 
  if (p %in% c("mit_density", "mit_potential", "ROS", "DNAdamage")){
    formula <- paste0(p, "~ cort*temp + (1|clutch)")
  } else if (p == "peroxidation"){
    formula <- paste0(p, "~ cort*temp + age + (1|clutch)")
  } 
  pmodel_name <- paste0("m_def_", p)
  assign(pmodel_name, fit_m(df = clean_df,
                          cat = "def",
                          var = p,
                          formula = formula,
                          fam = gaussian(),
                          refit = FALSE),
        envir = .GlobalEnv)  # Assign to the global environment
} 
```

```{r, models_learning}
#| label: models_learning
#
formula_learn <- errors ~ day*cort*temp + (1 + day|lizard_id) + (1|clutch)
m_def_learn <- fit_m(df = learning_df,
                      cat = "def",
                      var = "learning",
                      formula = formula_learn,
                      fam = negbinomial(link = "log"),
                      refit = FALSE)
```

```{r, organise_posteriors_learning}
#| label: organise_posteriors_learning
# Rename some of the posteriors and make new estimates for the learning rate 
#
### Slopes
slope_ControlCold <- m_def_learn$b_day
slope_CORTCold <- m_def_learn$b_day + m_def_learn$`b_day:cortCORT`
slope_ControlHot <- m_def_learn$b_day + m_def_learn$`b_day:tempHot`
slope_CORTHot <- m_def_learn$b_day + m_def_learn$`b_day:cortCORT:tempHot` + m_def_learn$`b_day:cortCORT` + m_def_learn$`b_day:tempHot`
### Intercepts (for figure)
int_ControlCold <- m_def_learn$b_Intercept
int_CORTCold <- m_def_learn$b_Intercept + m_def_learn$`b_cortCORT`
int_ControlHot <- m_def_learn$b_Intercept + m_def_learn$`b_tempHot`
int_CORTHot <- m_def_learn$b_Intercept + m_def_learn$`b_cortCORT:tempHot` + m_def_learn$`b_cortCORT` + m_def_learn$`b_tempHot`
```

```{r, fig-learning}
#| label: fig-learning
#| fig.cap: "Results for learning analyses. (a) the predicted number of errors over trials. The lines represent the mean predicted number of errors for each trial, and the shaded areas indicate the standard error of the mean; both were obtained using the slope and intercept estimates from the posterior distributions. (b) shows the distribution of the estimates of slopes per each treatment. The x-axis represents the slope estimate, and in the y-axis are the density of the estimates. Points and bars represent the mean and standard error of the estimated slopes, respectively. Dashed lines indicate value 0. The different colors in both panels indicate the different treatments. Asterisks in (b) indicate significant differences from 0."
source(here("R", "func.R"))
#
#
####### A) Create df
# Slopes df (employed in fig-learning B)
slope_list <- list(`Control-Cold` = slope_ControlCold,
                 `CORT-Cold` = slope_CORTCold,
                 `Control-Hot` = slope_ControlHot,
                 `CORT-Hot` = slope_CORTHot)
data_fig_learning_slopes <- do.call(rbind, lapply(names(slope_list), function(x) {
  data.frame(treatment = x, slopes = slope_list[[x]])
}))
# Intercepst df (only for fig-learning A)
intercept_list <- list(`Control-Cold` = int_ControlCold,
                 `CORT-Cold` = int_CORTCold,
                 `Control-Hot` = int_ControlHot,
                 `CORT-Hot` = int_CORTHot)
data_fig_learning_intercepts <- do.call(rbind, lapply(names(intercept_list), function(x) {
  data.frame(treatment = x, intercepts = intercept_list[[x]])
})) %>% 
  group_by(treatment) %>%
  summarize(int_sd = sd(intercepts),
            intercepts = mean(intercepts))
# df fig-learning A
data_fig_learning_slopesA <- data_fig_learning_slopes %>%
  group_by(treatment) %>%
  summarize(slope_sd = sd(slopes),
            slopes = mean(slopes),)
data_fig_learningA <- merge(data_fig_learning_slopesA, data_fig_learning_intercepts, by = "treatment")
treatment <- unique(data_fig_learningA$treatment)
fig_A_df <- data.frame()
for(t in treatment){ # Loop per treatment
  df <- data_fig_learningA %>%
    filter(treatment == t) %>%
    data.frame()
  # Variables selected
  m <- df$slopes
  u <- df$intercepts
  # Loop per treatment
  num_individuals <- length(u)
  for(x in 0:40){
    if (x == 0){
      sd <- df$int_sd
    } else {
      q25 <- df$slope_sd
    }
    value <- exp(u + m * x)
    temp_df <- data.frame(trial = rep(x, length(value)),
                          treatment = rep(t, length(value)),
                          errors = value,
                          sd = sd * value)
    fig_A_df <- rbind(fig_A_df, temp_df)
  }
}
# 
#### C) Plot the fig-learning A and fig-learning B separately 
fig_learningA <- plot_errorsday(fig_A_df)
fig_learningB <- plot_slopes(data_fig_learning_slopes)
#
#### D) Combine plots A and B to have fig-learning
fig_results_learning <- plot_grid(fig_learningA, fig_learningB, nrow = 1) +
  # Insert title for each plot
  annotate("text", x = 0.045, y = 0.935, label = "A", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.545, y = 0.935, label = "B", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.705, y = 0.89, label = "*", hjust = 1, vjust = 1, size = 7) +
  annotate("text", x = 0.68, y = 0.72, label = "*", hjust = 1, vjust = 1, size = 7) +
  annotate("text", x = 0.7, y = 0.55, label = "*", hjust = 1, vjust = 1, size = 7) +
  annotate("text", x = 0.69, y = 0.38, label = "*", hjust = 1, vjust = 1, size = 7)
#
ggsave("./output/figures/text/fig_results_errors.png", plot=fig_results_learning , width = 21, height = 7, units = "cm", dpi = 600)
knitr::include_graphics("./output/figures/text/fig_results_errors.png")
``` 

We found that the lizards improved their choices over time, making less mistakes as the trials progressed (see @fig-learning and table S1). However, the learning rate was not influenced by CORT, temperature, or their interaction (see contrasts in table S2).

Mitochondrial density, metabolic capacity, ROS, DNA damage, and lipid peroxidation were also not affected by prenatal conditions (see @fig-results_mit and table S2). We did not see any significant effects of sex and age on mitochondrial physiology either (see table S3 and tables S5-S9).

```{r, organise_posteriors_mit}
#| label: organise_posteriors_mit
#
# Organising the posteriors of the previous models for tables and figures
#
source(here("R", "func.R"))
#
#
post_mit <- data.frame()
# Names posteriors:
names <- c("m_def_mit_density", "m_def_mit_potential", "m_def_ROS", "m_def_DNAdamage", "m_def_peroxidation")
#
# Organising the results
for (pos in names) {
  model <- get(pos)      # Get the model from the global environment
  post_result <- tidy_post(model)        # Apply tidy_post to each model
  # Add a new column to the rmodel
  post_result$Model <- pos
  post_mit <- bind_rows(post_mit, post_result)
}
#
#
#
# Extracting the posteriors for the models with mitochondrial variables and the values of interest. Here, I am creating dfs for each of the variables with the values for all the prenatal conditions to make contrasts easier to write.
#
MD <- post_values(m_def_mit_density, "none")
MP <- post_values(m_def_mit_potential, "none")
ROS <- post_values(m_def_ROS, "none")
DNA <- post_values(m_def_DNAdamage, "none")
LP <- post_values(m_def_peroxidation, "none")
```

```{r, fig-results_mit}
#| label: fig-results_mit
#| fig-cap: "Estimates of mitochondrial density (a), metabolic capacity (b), ROS (c), DNA damage (d), and lipid peroxidation (e) in the medial cortex as a function of the different prenatal conditions. Note that for (d) and (e) these analyses do not account for missing data resulting from a flow cytometer malfunction that impacted one plate, and so, sample sizes are lower for univariate analyses. The x-axis represents the estimated values and in the y-axis is the density of the estimates. Points and bars represent the mean and standard error of the estimated values, respectively. The different colors in both panels indicate the different treatments."
#| fig-name: "fig-results_oxidative"
#
source(here("R", "func.R"))
#
# A) Plotting the results for all variables
plot_mit_density <- plotting(MD, "Mit density")
plot_mit_potential <- plotting(MP, "Metabolic capacity")
plot_ros <- plotting(ROS, "ROS")
#
plot_legend_top <- plotting(ROS, "ROS") + theme(legend.position = "bottom", legend.title = element_blank())
gtable <- ggplot_gtable(ggplot_build(plot_legend_top))
legend_mit_top <- gtable$grobs[[which(sapply(gtable$grobs, function(x) x$name) == "guide-box")]]
#
plot_dnadamage <- plotting(DNA, "DNA damage")
plot_peroxidation <- plotting(LP, "Lipid peroxidation")
#
plot_legend_bottom <- plotting(DNA, "DNA damage") + theme(legend.position = "bottom", legend.title = element_blank())
gtable <- ggplot_gtable(ggplot_build(plot_legend_bottom))
legend_mit_bottom <- gtable$grobs[[which(sapply(gtable$grobs, function(x) x$name) == "guide-box")]]
#
# B) Organising the plots
fig_mit_top <- plot_grid(plot_mit_density, plot_mit_potential,
                        nrow = 1, rel_widths = c(1, 1))
fig_mit_mid <- plot_grid(plot_ros, NULL,
                        nrow = 1, rel_widths = c(1, 1))
fig_mit_bottom <- plot_grid(plot_dnadamage, plot_peroxidation,
                        nrow = 1, rel_widths = c(1, 1))
#
# C) Merging everything in final figure
# Create the figure grid with extra space for legend
fig_mit <- plot_grid(
  fig_mit_top, fig_mit_mid, NULL, fig_mit_bottom, NULL,
  nrow = 5, rel_heights = c(0.3, 0.3, 0.05, 0.3, 0.05))
# Final composition: Merge everything, adding images and legend
final_plot_mit <- ggdraw(fig_mit) +
  # Insert legend in the middle for ROS and energy variables
  draw_grob(legend_mit_top, x = 0.49, y = 0.39, width = 0.01, height = 0.01) +
  # Insert legend in the bottom for DNA damage and lipid peroxidation
  draw_grob(legend_mit_bottom, x = 0.49, y = 0.03, width = 0.01, height = 0.01) +
  # Insert title for each plot
  annotate("text", x = 0.0325, y = 0.985, label = "A", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.531, y = 0.985, label = "B", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.0325, y = 0.682, label = "C", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.0325, y = 0.335, label = "D", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  annotate("text", x = 0.53, y = 0.335, label = "E", hjust = 1, vjust = 1, size = 7, fontface = "bold") +
  # Insert figure brain
  draw_image(here("./Others/brain_fig.png"), x = 0.53, y = 0.34, width = 0.45, height = 0.45)
#
# Print final plot
ggsave(here("./output/figures/text/results_mit.png"), plot = final_plot_mit, width = 21, height = 21, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/text/results_mit.png")
```

```{r, model_sem}
#| label: model_sem
# Making the SEM model by using a multivariate brms. The aim is to test the relationships between mitochondrial physiology and detection latency.
# Learning here was evaluated obtaining the learning slopes for each individual (see data_process.R).
# All continue variables were standardized (var/2SD) before running the models (see data_process.R). 
#
source(here("R", "func.R"))
#
refit <- FALSE
#
data_SEM <- clean_df %>%
  mutate(obs = 1:nrow(.),
        vec = rep(1, length(obs)))
if(refit){
  m_SEM <- brm(
    bf(slope_mean | se(slope_sd, sigma = FALSE) ~ mit_density + mit_potential + mi(DNAdamage) + mi(peroxidation) + (1|clutch) + (1|q|obs)) +
    bf(DNAdamage | mi() + se(vec, sigma = FALSE) ~ ROS + (1|clutch)+ (1|p|obs)) +
    bf(peroxidation | mi() + se(vec, sigma = FALSE) ~ ROS + (1|clutch) + (1|p|obs)) +
    bf(ROS | se(vec, sigma = FALSE) ~ mit_density + mit_potential + (1|clutch) + (1|t|obs)) +
  set_rescor(FALSE),
  family = gaussian(),
  data = data_SEM, 
  chains = 4, cores = 4, iter = 8000, warmup = 2000,
  control = list(adapt_delta = 0.99, max_treedepth = 15))
  # Save the model
  saveRDS(m_SEM, file = here("output/models/m_SEM.rds"))
} else {
  m_SEM <- readRDS(here("output/models/m_SEM.rds"))
}
```

```{r, sem_tidy}
#| label: sem_tidy
source(here("R", "func.R"))
#
# I am extracting here all the values for getting the total effects of each of the variables in the model. I am using the posterior values for each of the variables to get the total effects assuming that:
## total effect = direct effect + indirect effect + residual correlation
# In other words:
## total effect = 
# Extract the posteriors for the SEM model
post_sem <- as_draws_df(m_SEM) 
#
#### A) Get the direct paths / regression coefficients per each variable
# 
# A.1) Learning
coeff_mitodensity_learn <- post_sem$b_slopemean_mit_density
coeff_potential_learn <- post_sem$b_slopemean_mit_potential
coeff_dna_learn<- post_sem$bsp_slopemean_miDNAdamage
coeff_perox_learn <- post_sem$bsp_slopemean_miperoxidation
# 
# A.2) DNA damage
coeff_ros_dna <- post_sem$b_DNAdamage_ROS
#
# A.3) Lipid peroxidation
coeff_ros_perox <- post_sem$b_peroxidation_ROS
#
# A.4) ROS
coeff_mitodensity_ros <- post_sem$b_ROS_mit_density
coeff_potential_ros <- post_sem$b_ROS_mit_potential
#
#
#### B) Get the indirect paths for each variable
#
# B.1) Detection
undir_ros_learn <- coeff_ros_dna * coeff_dna_learn + coeff_ros_perox * coeff_perox_learn
undir_mitodensity_learn <- coeff_mitodensity_ros * coeff_ros_dna * coeff_dna_learn + coeff_mitodensity_ros * coeff_ros_perox * coeff_perox_learn
undir_potential_learn <- coeff_potential_ros * coeff_ros_dna * coeff_dna_learn + coeff_potential_ros * coeff_ros_perox * coeff_perox_learn
#
# B.2) DNA damage
undir_mitodensity_dna <- coeff_mitodensity_ros * coeff_ros_dna
undir_potential_dna <- coeff_potential_ros * coeff_ros_dna
#
# B.3) Lipid peroxidation
undir_mitodensity_perox <- coeff_mitodensity_ros * coeff_ros_perox
undir_potential_perox <- coeff_potential_ros * coeff_ros_perox
#
#
#### C) Get the total effects for each variable
#
# C.1) Detection
total_mitodensity_learn <- coeff_mitodensity_learn + undir_mitodensity_learn
total_potential_learn <- coeff_potential_learn + undir_potential_learn
total_ros_learn <- undir_ros_learn
total_dna_learn <- coeff_dna_learn
total_perox_learn <- coeff_perox_learn
#
# C.2) DNA damage
total_ros_dna <- coeff_ros_dna
total_mitodensity_dna <- undir_mitodensity_dna
total_potential_dna <- undir_potential_dna
#
# C.3) Lipid peroxidation
total_ros_perox <- coeff_ros_perox
total_mitodensity_perox <- undir_mitodensity_perox
total_potential_perox <- undir_potential_perox
#
# C.4) ROS
total_mitodensity_ros <- coeff_mitodensity_ros
total_potential_ros <- coeff_potential_ros
#
#
# D) Create a df with the values for each variable
#
# D.1) Detection (for example)
learn_sem <- data.frame(
  reference_variable = rep("learn", 5),
  predictor_modulator = c("mit_density",
                          "mit_potential",
                          "ROS",
                          "DNAdamage",
                          "peroxidation"),
  direct_effects = I(list(coeff_mitodensity_learn,
                          coeff_potential_learn,
                          NA,
                          coeff_dna_learn,
                          coeff_perox_learn)),
  indirect_effects = I(list(undir_mitodensity_learn,
                          undir_potential_learn,
                          undir_ros_learn,
                          NA,
                          NA)),
  total_effects = I(list(total_mitodensity_learn,
                        total_potential_learn,
                        total_ros_learn,
                        total_dna_learn,
                        total_perox_learn))
  ) %>% 
  group_by(predictor_modulator) %>%
  summarize(
    # Summarizing each list column (direct_effects, indirect_effects, etc.)
    mean_direct_effects = format_dec(mean(unlist(direct_effects), na.rm = TRUE), 3),
    mean_indirect_effects = format_dec(mean(unlist(indirect_effects), na.rm = TRUE), 3),
    mean_total_effects = format_dec(mean(unlist(total_effects), na.rm = TRUE), 3),
    q5_direct = format_dec(quantile(unlist(direct_effects), 0.05, na.rm = TRUE), 3),
    q95_direct = format_dec(quantile(unlist(direct_effects), 0.95, na.rm = TRUE), 3),
    q5_indirect = format_dec(quantile(unlist(indirect_effects), 0.05, na.rm = TRUE), 3),
    q95_indirect = format_dec(quantile(unlist(indirect_effects), 0.95, na.rm = TRUE), 3),
    q5_total = format_dec(quantile(unlist(total_effects), 0.05, na.rm = TRUE), 3),
    q95_total = format_dec(quantile(unlist(total_effects), 0.95, na.rm = TRUE), 3)) %>%
  mutate(source = "learn_sem")
#
# D.2) DNA damage
DNA_sem <- data.frame(
  reference_variable = rep("DNA damage", 3),
  predictor_modulator = c("mit_density",
                          "mit_potential",
                          "ROS"),
  direct_effects = I(list(NA,
                          NA,
                          coeff_ros_dna)),
  indirect_effects = I(list(undir_mitodensity_dna,
                          undir_potential_dna,
                          NA)),
  total_effects = I(list(total_mitodensity_dna,
                        total_potential_dna,
                        total_ros_dna))) %>% 
  group_by(predictor_modulator) %>%
  summarize(
    # Summarizing each list column (direct_effects, indirect_effects, etc.)
    mean_direct_effects = format_dec(mean(unlist(direct_effects), na.rm = TRUE), 3),
    mean_indirect_effects = format_dec(mean(unlist(indirect_effects), na.rm = TRUE), 3),
    mean_total_effects = format_dec(mean(unlist(total_effects), na.rm = TRUE), 3),
    q5_direct = format_dec(quantile(unlist(direct_effects), 0.05, na.rm = TRUE), 3),
    q95_direct = format_dec(quantile(unlist(direct_effects), 0.95, na.rm = TRUE), 3),
    q5_indirect = format_dec(quantile(unlist(indirect_effects), 0.05, na.rm = TRUE), 3),
    q95_indirect = format_dec(quantile(unlist(indirect_effects), 0.95, na.rm = TRUE), 3),
    q5_total = format_dec(quantile(unlist(total_effects), 0.05, na.rm = TRUE), 3),
    q95_total = format_dec(quantile(unlist(total_effects), 0.95, na.rm = TRUE), 3)) %>%
  mutate(source = "DNA_sem")
#
# D.3) Lipid peroxidation
perox_sem <- data.frame(
  reference_variable = rep("lipid peroxidation", 3),
  predictor_modulator = c("mit_density",
                          "mit_potential",
                          "ROS"),
  direct_effects = I(list(NA,
                          NA,
                          coeff_ros_perox)),
  indirect_effects = I(list(undir_mitodensity_perox,
                          undir_potential_perox,
                          NA)),
  total_effects = I(list(total_mitodensity_perox,
                        total_potential_perox,
                        total_ros_perox))) %>% 
  group_by(predictor_modulator) %>%
  summarize(
    # Summarizing each list column (direct_effects, indirect_effects, etc.)
    mean_direct_effects = format_dec(mean(unlist(direct_effects), na.rm = TRUE), 3),
    mean_indirect_effects = format_dec(mean(unlist(indirect_effects), na.rm = TRUE), 3),
    mean_total_effects = format_dec(mean(unlist(total_effects), na.rm = TRUE), 3),
    q5_direct = format_dec(quantile(unlist(direct_effects), 0.05, na.rm = TRUE), 3),
    q95_direct = format_dec(quantile(unlist(direct_effects), 0.95, na.rm = TRUE), 3),
    q5_indirect = format_dec(quantile(unlist(indirect_effects), 0.05, na.rm = TRUE), 3),
    q95_indirect = format_dec(quantile(unlist(indirect_effects), 0.95, na.rm = TRUE), 3),
    q5_total = format_dec(quantile(unlist(total_effects), 0.05, na.rm = TRUE), 3),
    q95_total = format_dec(quantile(unlist(total_effects), 0.95, na.rm = TRUE), 3)) %>%
  mutate(source = "perox_sem")
#
# D.4) ROS
ROS_sem <- data.frame(
  reference_variable = rep("ROS", 2),
  predictor_modulator = c("mit_density",
                          "mit_potential"),
  direct_effects = I(list(coeff_mitodensity_ros,
                          coeff_potential_ros)),
  indirect_effects = I(list(NA,
                          NA)),
  total_effects = I(list(total_mitodensity_ros,
                        total_potential_ros))) %>% 
  group_by(predictor_modulator) %>%
  summarize(
    # Summarizing each list column (direct_effects, indirect_effects, etc.)
    mean_direct_effects = format_dec(mean(unlist(direct_effects), na.rm = TRUE), 3),
    mean_indirect_effects = format_dec(mean(unlist(indirect_effects), na.rm = TRUE), 3),
    mean_total_effects = format_dec(mean(unlist(total_effects), na.rm = TRUE), 3),
    q5_direct = format_dec(quantile(unlist(direct_effects), 0.05, na.rm = TRUE), 3),
    q95_direct = format_dec(quantile(unlist(direct_effects), 0.95, na.rm = TRUE), 3),
    q5_indirect = format_dec(quantile(unlist(indirect_effects), 0.05, na.rm = TRUE), 3),
    q95_indirect = format_dec(quantile(unlist(indirect_effects), 0.95, na.rm = TRUE), 3),
    q5_total = format_dec(quantile(unlist(total_effects), 0.05, na.rm = TRUE), 3),
    q95_total = format_dec(quantile(unlist(total_effects), 0.95, na.rm = TRUE), 3)) %>%
  mutate(source = "ROS_sem")
#
#
# E) Merge everything into a single df
#
sem_results <- bind_rows(learn_sem, DNA_sem, perox_sem, ROS_sem)
```

Our SEM showed that mitochondrial physiology was not related to learning abilities (see @fig-sem and table S4). While we found that ROS production increased with metabolic capacity (β = `r format_dec(mean(coeff_potential_ros), 3)`, 95% CI = [`r format_dec(quantile(coeff_potential_ros, 0.025), 3)`, `r format_dec(quantile(coeff_potential_ros, 0.975), 3)`], _pMCMC_ `r format_p(pmcmc(coeff_potential_ros), 3, equal = TRUE)`), ROS was not related to  oxidative damage (see @fig-sem and table S4).

```{r, fig-sem}
#| label: fig-sem
#| fig-cap: "Structural equation model testing hypothesized direct and indirect effects of physiology on learning. Arrows indicate the directionality of the estimate, and the values show the mean predicted coefficient and its 95% confidence interval."
#| fig-name: "fig-sem"
# 
# A) Getting all the direct coefficients
density_learn <- paste0(format_dec(mean(coeff_mitodensity_learn), 3),
                  " [", format_dec(quantile(coeff_mitodensity_learn, 0.05), 3),
                  ", ", format_dec(quantile(coeff_mitodensity_learn, 0.95), 3), "]")
potential_learn <- paste0(format_dec(mean(coeff_potential_learn), 3),
                  " [", format_dec(quantile(coeff_potential_learn, 0.05), 3),
                  ", ", format_dec(quantile(coeff_potential_learn, 0.95), 3), "]")
dna_learn <- paste0(format_dec(mean(coeff_dna_learn), 3),
                  " [", format_dec(quantile(coeff_dna_learn, 0.05), 3),
                  ", ", format_dec(quantile(coeff_dna_learn, 0.95), 3), "]")
perox_learn <- paste0(format_dec(mean(coeff_perox_learn), 3),
                  " [", format_dec(quantile(coeff_perox_learn, 0.05), 3),
                  ", ", format_dec(quantile(coeff_perox_learn, 0.95), 3), "]")
#
ros_dna <- paste0(format_dec(mean(coeff_ros_dna), 3),
                  " [", format_dec(quantile(coeff_ros_dna, 0.05), 3),
                  ", ", format_dec(quantile(coeff_ros_dna, 0.95), 3), "]")
#
ros_perox <- paste0(format_dec(mean(coeff_ros_perox), 3),
                  " [", format_dec(quantile(coeff_ros_perox, 0.05), 3),
                  ", ", format_dec(quantile(coeff_ros_perox, 0.95), 3), "]")
#
density_ros <- paste0(format_dec(mean(coeff_mitodensity_ros), 3),
                  " [", format_dec(quantile(coeff_mitodensity_ros, 0.05), 3),
                  ", ", format_dec(quantile(coeff_mitodensity_ros, 0.95), 3), "]")
potential_ros <- paste0(format_dec(mean(coeff_potential_ros), 3),
                  " [", format_dec(quantile(coeff_potential_ros, 0.05), 3),
                  ", ", format_dec(quantile(coeff_potential_ros, 0.95), 3), "]")
#
imgSEM <- readPNG(here("Others", "SEM.png"))
plot_SEM <- rasterGrob(imgSEM, interpolate = TRUE)
#
fig_SEM <- ggdraw(plot_SEM) +
  annotate("text", x = 0.433, y = 0.19, label = density_learn, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.433, y = 0.85, label = potential_learn, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.877, y = 0.675, label = dna_learn, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.877, y = 0.387, label = perox_learn, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.547, y = 0.745, label = ros_dna, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.547, y = 0.295, label = ros_perox, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.325, y = 0.284, label = density_ros, hjust = 1, vjust = 1, size = 3.5, family = "Times") +
  annotate("text", x = 0.324, y = 0.757, label = potential_ros, hjust = 1, vjust = 1, size = 3.5, family = "Times")
ggsave(here("./output/figures/text/SEM.png"), plot = fig_SEM, width = 21, height = 10, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/text/SEM.png")
```

## Discussion
Lizards were able to learn a complex spatial task with marked improvements over time in their ability to choose the correct location. However, learning was not influenced by prenatal conditions or linked to mitochondrial function in the medial cortex, counter to what we predicted. Despite ROS increasing with greater metabolic capacity as expected, this did not result in a corresponding increase in oxidative damage in the medial cortex in _L. delicata_. We discuss our results in relation to existing work exploring the underlying mechanisms of learning and how early environments impact it below.  

#### Spatial learning is robust to prenatal conditions  
Lizards exhibited clear evidence for learning but learning rates were not influenced by prenatal CORT or temperature as we predicted. This contrasts with findings in other taxa, where incubation temperature and prenatal GC’s have both been shown to affect learning and brain development [@lemaire_prenatal_2000; @zhu_prenatal_2004; @amiel_hotter_2012; @amiel_effects_2017; @dayananda_incubation_2017]. Our results suggest that spatial learning abilities in _L. delicata_ are buffered from early environmental insults, consistent with our previous findings showing that behavioural flexibility in this species is also unaffected by prenatal CORT or temperature [@recio2025early]. _L. delicata_'s resilience may stem from the adaptive value of learning in lizards. For example, spatial learning in velvet geckos (_Amalosia lesueurii_) enhances survival in the wild [@dayananda_incubation_2017]. Future studies should investigate the mechanisms underlying this robustness and the role of cognition in _L. delicata_'s fitness.  

#### Brain metabolic physiology is not affected by prenatal conditions   
Contrary to our predictions, prenatal temperature and CORT did not significantly influence mitochondrial physiology in the medial cortex of _L. delicata_. Studies in other taxa have shown that incubation at high temperatures decrease energy production and oxidative stress [@treidel2016temperature; @zavorka_climate_2021], while elevated GCs or maternal stress is related to lower mitochondrial efficiency and higher oxidative damage [@costantini2011meta; @gong_chronic_2011; but see @crino2024eggs]. In _L. delicata_, high incubation temperatures are known to decrease mitochondrial efficiency in the liver [@crino2024eggs]. However, our study shows that mitochondrial physiology in _L. delicata_’s brain is robust to both incubation temperature and prenatal CORT. This could reflect differential tissue responses to early-life conditions, highlighting the importance of studying these effects across multiple tissues.   

#### Variation in brain metabolic physiology is not related to learning abilities
Mitochondria play a critical role for cognitive function by synthesizing energy [@siegel1994basic; @du_dynamic_2009; @picard_mitochondria_2014; @picard_energetic_2018], and by affecting the rate of cell senescence and death caused by oxidative damage [@mcnay_decreases_2000; @mann_coupling_2021; @alexandrov_neuronal_2022]. For example, donut-shaped mitochondria are associated with higher ROS production in presynaptic neurons and this mechanism has been shown to impair visuospatial working-memory in rhesus monkeys (_Macaca mulatta_) [@hara_presynaptic_2014].  

Our findings contrast with these studies and suggest that energy limitations do not impact the process of spatial learning in _L. delicata_. The lack of association between mitochondrial density, mitochondrial capacity, and learning abilities may be the result of lizards being able to maintain energy production above the threshold required to prevent cognitive dysfunction. The generally low energetic demands of ectothermic organisms compared to endotherms may make this possible and explain why we found no effect when they seem to be common in mammals [@hara_presynaptic_2014; @cao2014ampk].   

Interestingly, despite finding a significant positive relationship between metabolic capacity and ROS in the medial cortex, the heightened ROS production did not lead to greater oxidative stress. The strong relationship between ROS and mitochondrial capacity aligns with the role of mitochondrial membrane potential in driving ATP synthesis and electron transport, processes that inherently generate ROS as byproducts [@rice2002brain]. Normally, moderate ROS levels serve essential signaling functions and are controlled by antioxidants [@rice2002brain; @terman2006oxidative]. However, excessive ROS production can exceed antioxidant action, leading to oxidative stress and cellular dysfunction [@rice2002brain; @terman2006oxidative]. The lack of oxidative damage from increased ROS strongly suggests that antioxidants could deal with these levels of ROS. As such, DNA damage and lipid peroxidation in the medial cortex were not linked to spatial learning in _L. delicata_ possibly because neurons were effectively buffered from damaging free radicals. Nevertheless, since oxidative damage can accumulate over time [@terman2006oxidative], the relationships between oxidative damage and cognitive dysfunction could become more pronounced in older individuals [@hara_presynaptic_2014]. Future research should investigate the long-term consequences of mitochondrial activity on brain health and the potential mechanisms that sustain cognitive resilience in _L. delicata_.  
  
#### Conclusions
We found that spatial learning in _L. delicata_ was not influenced by prenatal CORT or temperature, nor was mitochondrial physiology in the medial cortex. Additionally, there was no relationship between mitochondrial function and learning abilities in a spatial task. However, we found that ROS production increased with metabolic capacity, suggesting that links between mitochondrial respiration and oxidative stress may become more pronounced under higher energetic demands or with aging, potentially influencing cognitive function over time.  



### Ethics
Both the breeding animals and the experimental lizards were provided humane laboratory housing, with thermoregulatory opportunities, light (UV and heat) and moderate levels of humidity (see Methods 1: Animal husbandry in Supplementary Material for details). Euthanasia was performed by peritoneal injection of a 10 mg/kg of a 10 mg/mL alfaxan solution (a potent anesthetic) followed by decapitation. We monitored the animals to ensure there was no irritation from the agent as indicated by distressed animals. Before disposing of the lizard, we confirmed the absence of righting response and the pinching reflex in one of the front limbs. All the protocols complied with Australian law and were approved by the Australian National University Animal Experimentation Ethics Committee (A2022_33).

### Data accessibility  
All data, data description, and R code are available in public repository [https://github.com/Pablo-Recio/CORT-Temp_Spatial_learning](https://github.com/Pablo-Recio/CORT-Temp_Spatial_learning).  

### Declaration of AI use
We declare Chat GPT was used mainly for questions related to coding and data analyses. All other parts of the manuscript were written by the authors and those parts where AI was used were checked and modified accordingly by the authors.  

### Authors' contributions
P.R.: conceptualization, methodology, data collection, data curation, formal analysis, writing—original draft, writing—review and editing; D.C.L.: conceptualization, methodology, data collection, writing—review and editing; O.C.: conceptualization, methodology, writing—review and editing; C.F.: conceptualization, methodology, funding acquisition, writing—review and editing; D.N.: conceptualization, methodology, funding acquisition, project administration, resources, supervision, writing—review and editing.  
All authors gave final approval for publication and agreed to be held accountable for the work performed therein.  

### Conflict of interest declaration  
We declare we have no competing interests.  

### Funding
This work was supported by a National Australian University fellowship (to P.R. and D.C.L.), and the Australian Research Council (grant no. DP210101152) to D.N. and C.R.F.

### Acknowledgements
We thank Dr. Mick Devoy and the Cytometry, Histology and Spatial Multiomics team for their advice and help througout the flow cytometry protocols. We thank the help and assistance of our lab technicians Benjamin Durant and Michelle Stephens for taking care of the lizards. We also thank ANU MakerSpace, where we designed and built the prototypes of the 3D printed feeders. Finally, we wish to acknowledge the anonymous reviewers for their valuable feedback on the manuscript. 

## References
<div id="refs"></div>

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```



# Suplementary Material  

#### Methods 1: Animal husbandry

*Breeding colony* - Juveniles of _L. delicata_ came from a breeding colony established in the laboratory since 2019. This colony consisted of 270 adults housed in plastic containers (41.5 L x 30.5 W x 21 H cm) with six lizards (two males and four females) per enclosure. Enclosures were provided with shelter, nonstick matting, and several small water dishes. The lizards were fed approx. 40 mid-size crickets (_Acheta domestica_) per enclosure three days a week, and water was given daily. The crickets were dusted with calcium weekly and multivitamin and calcium biweekly. Room temperatures were set to 22-24 ºC, but we also provided the enclosures with a heat chord and a heat lamp following a 12 h light:12 h dark cycle keeping warm side of enclosures is usually at 34 ºC.

*Eggs collection and incubation* - Between mid-November 2023 to mid-January 2024, we placed a small box (12.5 L x 8.3 W x 5 H cm) with moist vermiculite in one side of the communal enclosures to provide females with a place to lay the eggs. These boxes were checked three days a week. After egg collection, we measured length and width with a digital caliper to the nearest 0.1 mm and weighted the eggs with a digital scale ± 0.001g error. Then eggs were treated with CORT or vehicle (see CORT and temperature manipulation below) and were placed in individual cups (80 mL) with moist vermiculite (12 parts water to 4 parts vermiculite). The cups were covered with cling wrap to retain moisture and left in two incubators at two different temperatures (see CORT and temperature manipulation below) until hatching.

*Hatchlings* - Incubators were checked three times a week for hatchlings. Lizards were measured and weighed immediately after hatching. snout-vent length (SVL) and tail length (TL) were measured to the nearest millimeter, and weight was recorded using a digital scale with an accuracy of ± 0.001 g. Hatchlings were then placed in individual enclosures (18.7L x 13.2W x 6.3H cm) with nonstick matting and a small water dish. Watering, feeding, and temperature conditions were maintained as for adults (see above).      

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


#### Methods 2: flow cytometry

#### Brain mitochondrial activity
_Homogenates_
After the medial cortex was extracted, it was transferred immediately to 1.5mL centrifuge tubes containing 100µL of cold 1X PBS and kept on ice until further processing. The tissue was mechanically homogenized by placing the tissue in the well of a 100µm mesh filter (pluriStrainer) affixed atop a 1.5mL centrifuge tube, then mashed with the rubber end of an insulin syringe stopper. The resulting homogenate was then rinsed through the filter with 1000µL of cold 1X PBS to prepare a homogenate suspension. Following homogenization, we centrifuged each sample at 1000 RCF for 10 minutes to pellet cells, then removed the supernatant (hereafter, this process referred to as ‘washing’) and resuspended the cells in 500µL 1x PBS. This step was to performed to remove cellular debris from homogenates. 

From each 500µL suspension of homogenate collected on a given trial day, we first added 100µL of homogenate to a pooled sample of each tissue type to use for single-color controls, and the remaining 400µL of homogenate was split among two 200µL aliquots. One aliquot was used fresh to measure mitochondrial function (mitochondrial density, membrane potential, ROS), one aliquot was cryopreserved for later measurements of oxidative damage (8-OHdG, lipid peroxidation), and the third aliquot was cryopreserved for a different experiment. 

_Staining fresh samples_
From fresh homogenate suspensions, we loaded the wells of a 96-well flat-bottom plate (Nunclon) with 50µL of homogenate in duplicates (2 wells per homogenate). To each replicate well, we added 5µL of a fluorescent probe mix containing equal parts 5µM MitoTracker Deep Red FM, 2.5µM MitoTracker Orange CMTMRos, and 50µM MitoSOX Red. We used these fluorescent probes as indicators of mitochondrial density, mitochondrial membrane potential, and superoxide (ROS) production, respectively. We then added 5µL of 10 µg/mL Hoechst 33342 Nuclear Viability Dye to each sample, which we used to distinguish live, viable, intact cells from cellular debris. We then loaded 6 wells with 50µL of homogenate taken from each pooled homogenate suspension (12 wells total), which were to be negative and single-color controls. One well was left unstained as a negative control, one was stained with all the probes to be a positive control, and the remaining four wells were treated with 5µL of one of 5µM MitoTracker Deep Red FM, 2.5µM MitoTracker Orange CMTMRos, 50µM MitoSOX Red, or 10 µg/mL Hoechst 33342 Nuclear Viability Dye. Any remaining pooled homogenate was fixed and frozen as previously described. We incubated the loaded plate at 32 °C for 30 minutes to stain and then diluted the samples with 50µL cold 1x PBS to halt the staining process. Upon the completion of staining, samples were immediately transferred to flow cytometry facilities for data collection and were sampled within 2 hours. Samples prepared this way remained viable for flow cytometry for approximately 5 hours post-staining at room temperature (~19°C) before cells began rapidly degrading (unpublished data).

The aliquots destined to the analysis of oxidative damage were stained with 20µL (10µL for controls) of 10 µg/mL Hoechst 33342 Nuclear Viability Dye and 20µL of 100µM BODIPY 665/676 Lipid Peroxidation Sensor and incubated at 32°C for 20 minutes. Following staining, we washed cells to prevent further binding of unbound fluorescent probes, then resuspended the pellet and continue with cryopreservation.  

_Cryopreservation_
Aliquots were fixed first by adding the samples into a 1mL solution of 1% Neutral-Buffered Formalin (as a fixative agent) and incubating them at 32°C for 20 min. Then we centrifuged the samples at 800-1200xg for 10 min to pellet cells, removed the supernatant, and resuspended the cells (from now on this process will be called as 'washing') in 1mL cold 1X Tris-EDTA (chelates metals that can damage DNA during freezing) and 10% DMSO (a cryoprotectant). Samples were stored at -20°C until oxidative damage assays.

_Staining cryopreserved samples_
Assays of oxidative damage from cryopreserved samples were performed within 6 months of the initial processing and analysis of fresh samples. On the day of oxidative damage assays, we rapidly thawed frozen samples by briefly (1-2 minutes) submerging them in hot water. We washed each thawed sample twice, the first time resuspending the pelleted cells in 1000µL warm 1X Tris-EDTA, and the second time in 200µL warm 1X PBS containing 5mM (6.14 mg/mL) digitonin. We incubated the samples at 32°C for 20 minutes to permeabilize the cell membrane, after which we washed the homogenate and resuspended the pelleted cells in 200µL 1X PBS. We added 20µL of 70µM 8-OHdG Polyclonal Antibody to each sample, and we left the homogenate overnight (~12 hours) for the antibody to bind to 8-OHdG, a marker of oxidative damage on DNA. The following day we counterstained the cells with 20µL of 100 µg/mL H+G Goat Anti-Rabbit Conjugate Antibody with Alexa-Fluor 488 at 32°C for 20 minutes. After the cells had been tagged with 8-OHdG antibodies and counterstained, we washed the cells once more and resuspended the pellet in 400µL of 1X PBS. Unstained and single-color controls were treated identically to samples, but stained with only up to one of BODIPY 665/676, Hoechst 33342, 8-OHdG antibody, or Alexa-Fluor 488 conjugate. Additionally, one control was stained with both 8-OHdG antibody and the Alexa-Fluor 488 conjugated. We then loaded a 96-well plate with 100µL of each single-color control and 100µL in triplicate of each sample. We performed all flow cytometry assays on samples within 48-hours of thawing the samples.  

_Flow cytometry_
All flow cytometry assays were performed using a flow cytometer with 5-lasers (blue, red, yellow-green, violet, and ultraviolet), 20 detectors, and a high-throughput plate reader (Becton Dickson LSRFortessa X-20) using the default wavelength filters on detectors. Immediately prior to all assays, we performed a quality-control check and laser alignment using the CS&T function of BD FACSDiva (v. 8.0.1) and BD CS&T fluorescent beads (Lot No. 30664) diluted at 2 drops to 150µL 1X PBS. During data collection, data for single-color controls was filtered using a liberal threshold of 200 on the FSC (roughly, cell size) detector, while data from samples was filtered using a threshold of 200 on the BUV-496 (Hoechst 33342) detector. These thresholds were chosen to filter small debris or inviable or non-intact cells from our observations. The detectors and voltage settings used in data acquisition for each assay type (mitochondrial function, oxidative damage) were determined during pilot trials prior to assays and were not changed during assays to allow for comparison among different plates and samples throughout the experiment. Voltages were chosen to center the distribution of observations in each channel at 103 fluorescent intensity and reduce observations of off-scale (<101 or >105) events. For the mitochondrial function assay, we recorded data from the following channels (in brackets: voltage; parameter): FSC (44; forward scatter), SSC (180; side scatter), Alexa-Fluor 488 (544; autofluorescence), BUV-496 (450; Hoechst 33342), APC (647; MitoTracker Deep Red FM), PE (522; MitoTracker Orange CMTMRos), and PerCP-Cy5-5 (592; MitoSOX Red) channels. For the oxidative damage assay, we recorded data from the following channels: FSC (425; forward scatter), SSC (300; side scatter), Alexa-Fluor 488 (275; 8-OHdG Antibody + Alexa-Fluor 488 conjugate), BUV-496 (525; Hoechst 33342), and PE-Cy5 (850; BODIPY 665/676). Fluorescent intensity data was collected via the BD FACSDiva (v. 8.0.1) software, with no compensation applied during data collection, and all on a linear scale (detectable range of 0-252166). We recorded data for both the area and height of the fluorescent signal, but only used the area in downstream analyses, with height being recorded for the sake of quality control. Data was exported from BD FACSDiva as individual *.fcs (“flow cytometry standard”) files for each sample, then imported into FlowJo (v. 10.1) for processing.

_Data processing_
In FlowJo v. 10.1 we first applied transformed all fluorescent data to a logarithmic base 10 scale, then applied a basic gating process across all channels by filtering to observations within the detectable range (101-105) to remove any off-scale events. We then used a backgating process wherein we aimed to identify the approximate FSC (cell size) and SSC (cell complexity) range of viable cells that were positive for all stains. We primarily used the BUV-496 channel (Hoechst 33342) in the backgating process to identify intact, nucleated cells (BUV-496 > 103). For the mitochondrial function assay, we aimed to identify populations of viable cells containing mitochondria (APC > 103) and actively respiring (PE and PerCP-Cy5-5 > 103). For the oxidative damage assay, we aimed to identify populations of cells exhibiting both DNA damage (Alexa-Fluor 488 > 103) and lipid peroxidation (PerCP > 103). When backgating was done, we filtered the data to the FSC by SSC range that captured the ideal population. We used the backgated population for compensation of fluorescent spillover between different fluorescent probes. To account for fluorescent spillover, we used a traditional compensation matrix using the compensation function of FlowJo v.10.1. We identified the “positive” population for each channel as the brightest ~2.5% of the distribution of observations in the respective single-color control for that channel and used unstained controls as a universal negative. We visually inspected the compensation matrix and its effects on population distributions for under- and over-compensation, whereupon we changed the compensation matrix manually until data was properly compensated. We applied the compensation matrix to all samples for downstream processing. Following compensation, we again gated the data following the same process as for backgating but using the compensated parameters for each channel. Following gating, we exported the geometric mean (mean fluorescent intensity; MFI) and robust confidence-values for each channel for each sample. For analysis, we exported summary statistics of only the area of the fluorescent signal. Although we exported robust confidence values for checking repeatability between replicate samples, we used the geometric means for each individual as our main response variables in analyses.


```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


#### Results of the final models

```{r, fig_learning_raw}
#| label: fig_learning_raw
#
source(here("R", "func.R"))
# Modify the df to plot the raw data
learning_df_plot <- learning_df %>%
  mutate(treatment = factor(trt, levels = c("B_23", "A_23", "B_28", "A_28"),
                      labels = c("B_23" = "CORT-Cold (n=20)",
                                 "A_23" = "Control-Cold (n=20)",
                                 "B_28" = "CORT-Hot (n=19)",
                                 "A_28" = "Control-Hot (n=20)"))) %>%
  group_by(treatment, day) %>%
  mutate(mean_raw = mean(na.omit(errors)),
         sd_raw = sd(na.omit(errors))) %>%
data.frame()
# Get the plot and combine it with the modeled data
fig_raw_learning <- plot_errorsday(fig_A_df) +
  geom_point(data = learning_df_plot, aes(x = day, y = mean_raw, color = treatment), size = 1.5) +
  scale_color_manual(values = c("CORT-Cold (n=20)" = "#00008B",
                                "Control-Cold (n=20)" = "#68bde1",
                                "CORT-Hot (n=19)" = "#b50101",
                                "Control-Hot (n=20)" = "#fa927d")) +
  facet_grid(~treatment) +
  ylim(c(min(na.omit(learning_df_plot$mean_raw)), max(na.omit(learning_df_plot$mean_raw)))) +  # Adjust y-axis limits
  theme(
    axis.title = element_text(size = 12, family = "Times"),
    axis.text = element_text(size = 10, family = "Times"),
    legend.position = "bottom",
    legend.title = element_blank()
  )
ggsave("./output/figures/suppl/Figure_S1_learning_raw.png", plot=fig_raw_learning , width = 21, height = 15, units = "cm", dpi = 600)
knitr::include_graphics("./output/figures/suppl/Figure_S1_learning_raw.png")
```

Figure S1. Raw data of the learning task. Each point represents the mean number of errors per day. The lines represent the modeled data.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

_Table S1. Estimates of the learning slopes per treatment, the 95% CI, and _pMCMC_ values testing the hypothesis that slope is different from 0. In bold, the values that are significant at _pMCMC_ < 0.05._
```{r, tbl-learning}
#| label: tbl-learning
#| tbl-cap: "Learning tasks slopes per treatment"
source(here("R", "func.R"))
#
table_learn_df <- data_fig_learning_slopes %>%
  group_by(treatment) %>%
  summarize(mean_slope = format_dec(mean(slopes), 3),
            q025_slope = format_dec(quantile(slopes, 0.025), 3),
            q975_slope = format_dec(quantile(slopes, 0.975), 3),
            pMCMC = format_p(pmcmc(slopes), 3, equal = FALSE)) %>%
  mutate(`95 CI` = paste0("[", q025_slope, ", ", q975_slope, "]")) %>%
  dplyr::select(treatment, mean_slope, `95 CI`, pMCMC)
#
# Make Table
set_flextable_defaults(
 font.family = "Times New Roman",
 font.size = 10)
#
table_slopes <- flextable(table_learn_df) %>%
  align(align = "center", j = c(3,4), part = "body") %>%
  align(align = "center", j = c(1:4), part = "header") %>%
  flextable::compose(j = 1, value = as_paragraph("Treatment"), part = "header") %>%
  flextable::compose(j = 2, value = as_paragraph("Estimated slope"), part = "header") %>%
  bold(~`pMCMC` == "< 0.05", j = c("pMCMC", "mean_slope", "95 CI", "treatment"),
       bold = TRUE) %>%  # Bold when PMCMC is "<0.05"
  bold(~`pMCMC` == "< 0.001", j = c("pMCMC", "mean_slope", "95 CI", "treatment")) %>%  # Bold when PMCMC is "<0.001"
  autofit()
#
table_slopes
```

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

_Table S2. Estimate of the contrasts between treatments for all the variables analysed, and _pMCMC_ values testing the hypothesis that contrast is different from 0. In bold, the values that are significant at _pMCMC_ < 0.05._
```{r tbl-contrasts}
#| label: tbl-contrasts
#| tbl-cap: "Contrasts between prenatal conditions for mitochondrial physiology and learning."
#
source(here("R", "func.R"))
#
# A) Modify posteriors df for learning where we only get/compare the slopes
LEARN <- data.frame(Control_Cold = slope_ControlCold, 
                  CORT_Cold = slope_CORTCold,
                  Control_Hot = slope_ControlHot,
                  CORT_Hot = slope_CORTHot)

# B) Organise df for mit physiology & learning
var <- c("MD", "MP", "ROS", "DNA", "LP", "LEARN")
data_table <- data.frame()
for(x in var){
  df <- get(x)
  Temperature <- format_dec(mean(c(df$CORT_Hot, df$Control_Hot)) - mean(c(df$CORT_Cold, df$Control_Cold)), 3)
  pMCMC_temp <- format_p(pmcmc(c(df$CORT_Hot, df$Control_Hot) - c(df$CORT_Cold, df$Control_Cold)), 3, equal = FALSE)
  CORT <- format_dec(mean(c(df$Control_Hot, df$Control_Cold)) - mean(c(df$CORT_Hot, df$CORT_Cold)), 3)
  pMCMC_cort <- format_p(pmcmc(c(df$Control_Hot, df$Control_Cold) - c(df$CORT_Hot, df$CORT_Cold)), 3, equal = FALSE)
  Interaction <- format_dec((mean(df$Control_Hot) - mean(df$CORT_Hot)) - (mean(df$Control_Cold) - mean(df$CORT_Cold)), 3)
  pMCMC_int <- format_p(pmcmc((df$Control_Hot - df$CORT_Hot) - (df$Control_Cold - df$CORT_Cold)), 3, equal = FALSE)
  data_temp <- data.frame(Variable = x,
                          Temperature = as.numeric(Temperature),
                          pMCMC_temp = as.numeric(pMCMC_temp),
                          CORT = as.numeric(CORT),
                          pMCMC_cort = as.numeric(pMCMC_cort),
                          Interaction = as.numeric(Interaction),
                          pMCMC_int = as.numeric(pMCMC_int))
  data_table <- dplyr::bind_rows(data_table, data_temp)
}
# Modify the df
data_table_final <- data_table %>%
  pivot_longer(cols = c(Temperature, CORT, Interaction), 
               names_to = "Predictor", 
               values_to = "Contrast") %>%
  mutate(
    # Extract the pMCMC values from the corresponding columns
    `pMCMC contrast` = case_when(
      Predictor == "Temperature" ~ pMCMC_temp,
      Predictor == "CORT" ~ pMCMC_cort,
      Predictor == "Interaction" ~ pMCMC_int
    )
  ) %>%
  mutate(
    Variable = case_when(
      Variable == "MD" ~ "Mit density",
      Variable == "MP" ~ "Metabolic capacity",
      Variable == "ROS" ~ "ROS",
      Variable == "DNA" ~ "DNA damage",
      Variable == "LP" ~ "Lipid peroxidation",
      Variable == "LEARN" ~ "Learning slopes",
      TRUE ~ Variable
      )
    ) %>%
  dplyr::select(Variable, Predictor, Contrast, `pMCMC contrast`)
#
# C) Make the contrasts table:
#
set_flextable_defaults(
 font.family = "Times New Roman",
 font.size = 10)
#
contrast_table <- flextable(data_table_final) %>%
  align(align = "center", j = c(3,4), part = "body") %>%
  align(align = "center", j = c(1:4), part = "header") %>%
  bold(~`pMCMC contrast` < 0.05, j = c("pMCMC contrast", "Contrast", "Predictor"),
       bold = TRUE) %>%  # Bold when PMCMC is "<0.05"
  bold(~`pMCMC contrast` <0.001, j = c("pMCMC contrast", "Contrast", "Predictor")) %>%  # Bold when PMCMC is "<0.001"
  flextable::compose(i = c(2,3,5,6,8,9,11,12,14,15,17,18), j = 1, value = as_paragraph(""), part = "body") %>% # To remove some of the values in the first column
  autofit()
#
contrast_table
```

Contrasts were done by:  
- _Temperature_: β~Hot~ - β~Cold~  
- _CORT_: β~CORT~ - β~Control~  
- _Interaction_: (β~Control-Hot~ - β~CORT-Hot~) - (β~Control-Cold~ - β~CORT-Cold~)  

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


#### Results SEM

_Table S3. Estimated direct, indirect, and total coefficients from the multivariate model_
```{r, table_sem_results}
#| label: table_sem_results
#| tbl-cap: "Structural Equation Models"
#
# Table created from the df sem_results_OB (see above)
source(here("R", "func.R"))
#
# Modify database
table_sem_df <- sem_results %>%
  mutate(`Direct effects` = paste0(mean_direct_effects, " [", q5_direct, ", ", q95_direct, "]"),
         `Indirect effects` = paste0(mean_indirect_effects, " [", q5_indirect, ", ", q95_indirect, "]"),
         `Total effects` = paste0(mean_total_effects, " [", q5_total, ", ", q95_total, "]")) %>%
  dplyr::select(source, predictor_modulator, `Direct effects`, `Indirect effects`, `Total effects`) %>%
  mutate(
      predictor_modulator = case_when(
        predictor_modulator == "mit_density" ~ "Mitochondrial density",
        predictor_modulator == "mit_potential" ~ "Metabolic capacity",
        predictor_modulator == "DNAdamage" ~ "DNA damage",
        predictor_modulator == "peroxidation" ~ "Lipid peroxidation",
        predictor_modulator == "ROS" ~ "ROS",
        TRUE ~ predictor_modulator
      ),
      source = case_when(
        source == "learn_sem" ~ "Learning",
        source == "DNA_sem" ~ "DNA damage",
        source == "perox_sem" ~ "Lipid peroxidation",
        source == "ROS_sem" ~ "ROS",
        TRUE ~ source
      ),
      `Direct effects` = case_when(`Direct effects` == "NaN [NA, NA]" ~ " - ", TRUE ~ `Direct effects`),
      `Indirect effects` = case_when(`Indirect effects` == "NaN [NA, NA]" ~ " - ", TRUE ~ `Indirect effects`),
      `Total effects` = case_when(`Total effects` == "NaN [NA, NA]" ~ " - ", TRUE ~ `Total effects`)) %>%
  rename(Predictor = predictor_modulator, Response = source) %>%
  mutate(Response = factor(Response, levels = c("Learning", "DNA damage", "Lipid peroxidation", "ROS")),
         Predictor = factor(Predictor, levels = c("Mitochondrial density",
                                                "Metabolic capacity",
                                                "ROS",
                                                "DNA damage",
                                                "Lipid peroxidation"))) %>%
  arrange(Response, Predictor)
#
# Table format
set_flextable_defaults(
 font.family = "Times New Roman",
 font.size = 10)
#
table_sem <- flextable(table_sem_df) %>%
  align(align = "center", part = "header") %>%
  flextable::compose(i = c(2:5,7,8,10,11,13), j = 1, value = as_paragraph(""), part = "body") %>% # To remove some of the values in the first column
  flextable::hline(i = c(5,8,11), part = "body") %>% 
  autofit()
#
table_sem
```

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


#### Final univariate models diagnostics (plots)


```{r , plotmod_mitdensity, out.width="70%", fig.align="center"}
#| label: plotmod_mitdensity
#| caption: "Posterior predictive checks for the model of Mitochondrial Density in Olfactory Bulbs."
#
mod <- readRDS(here("output/models/mit_density_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
#
fig_mod <- plot_grid(plot_mod_1, plot_mod_2, ncol = 1)
ggsave("./output/figures/suppl/Figure_S2.png", plot = fig_mod,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S2.png")
```

Figure S2. Posterior predictive checks for the model of Mitochondrial Density.
Formula: mit_density ~ cort * temp + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

```{r , plotmod_potential, out.width="70%", fig.align="center"}
#| label: plotmod_potential
#| caption: "Posterior predictive checks for the model of metabolic capacity."
#
mod <- readRDS(here("output/models/mit_potential_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
#
fig_mod <- plot_grid(plot_mod_1, plot_mod_2, ncol = 1)
ggsave("./output/figures/suppl/Figure_S3.png", plot = fig_mod,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S3.png")
```

Figure S3. Posterior predictive checks for the model of metabolic capacity.
Formula: mit_potential ~ cort * temp + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

```{r , plotmod_ros, out.width="70%", fig.align="center"}
#| label: plotmod_ros
#| caption: "Posterior predictive checks for the model of ROS."
#
mod <- readRDS(here("output/models/ROS_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
#
fig_mod <- plot_grid(plot_mod_1, plot_mod_2, ncol = 1)
ggsave("./output/figures/suppl/Figure_S4.png", plot = fig_mod,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S4.png")
```

Figure S4. Posterior predictive checks for the model of ROS.
Formula: ROS ~ cort * temp + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

```{r , plotmod_dnadamage, out.width="70%", fig.align="center"}
#| label: plotmod_dnadamage
#| caption: "Posterior predictive checks for the model of DNA damage."
#
mod <- readRDS(here("output/models/DNAdamage_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
#
fig_mod <- plot_grid(plot_mod_1, plot_mod_2, ncol = 1)
ggsave("./output/figures/suppl/Figure_S5.png", plot = fig_mod,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S5.png")
```

Figure S5. Posterior predictive checks for the model of DNA Damage.
Formula: DNAdamage ~ cort * temp + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

```{r , plotmod_peroxidation, out.width="70%", fig.align="center"}
#| label: plotmod_peroxidation
#| caption: "Posterior predictive checks for the model of lipid peroxidation."
#
mod <- readRDS(here("output/models/peroxidation_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
#
fig_mod <- plot_grid(plot_mod_1, plot_mod_2, ncol = 1)
ggsave("./output/figures/suppl/Figure_S6.png", plot = fig_mod,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S6.png")
```

Figure S6. Posterior predictive checks for the model of lipid peroxidation.
Formula: peroxidation ~ cort * temp + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

```{r , plotmod_learn, out.width="70%", fig.align="center"}
#| label: plotmod_learn
#| caption: "Posterior predictive checks for the model of learning."
#
mod <- readRDS(here("output/models/learning_def.rds"))
plot_mod <- plot(mod, plot = FALSE)
#
plot_mod_1 <- plot_mod[[1]]
plot_mod_2 <- plot_mod[[2]]
plot_mod_3 <- plot_mod[[3]]
#
ggsave("./output/figures/suppl/Figure_S7A.png", plot = plot_mod_1,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S7A.png")
#
ggsave("./output/figures/suppl/Figure_S7B.png", plot = plot_mod_2,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S7B.png")
#
ggsave("./output/figures/suppl/Figure_S7C.png", plot = plot_mod_3,
       width = 20, height = 28, units = "cm", dpi = 600, bg = "white")
knitr::include_graphics("./output/figures/suppl/Figure_S7C.png")
```

Figure S7. Posterior predictive checks for the model of spatial learning.
Formula: errors ~ day * cort * temp + (1 + day|lizard_id) + (1|clutch)

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


#### Results of preliminary models  

```{r, models_preliminary}
#| label: models_preliminary
# Fitting preliminary models to see if sex and age are relevant for our models
source(here("R", "func.R"))
#
#
var_m <- c("mit_density", "mit_potential", "ROS", "DNAdamage", "peroxidation")
formula_list_ <- list()
for (p in var_m){
  formula_list_[[p]] <- paste0(p, "~ cort*temp + age + sex + (1|clutch)")
  pmodel_name <- paste0("m_prel_", p)
  assign(pmodel_name, fit_m(df = clean_df,
                             cat = "prel",
                             var = p,
                             formula = formula_list_[[p]],
                             fam = gaussian(),
                             refit = FALSE),
          envir = .GlobalEnv)  # Assign to the global environment
}
#
#
# Run model learning including the effect of sex and interaction
formula_learn <- errors ~ day*cort*temp + sex + age + (1 + day|lizard_id) + (1|clutch)
m_prel_learn <- fit_m(df = learning_df,
                      cat = "prel",
                      var = "learning",
                      formula = formula_learn,
                      fam = negbinomial(link = "log"),
                      refit = FALSE)
```


_Table S4. Preliminary results of the models testing for Mitochondrial Density._
```{r, results_preliminary_mitdensity}
#| tbl-cap: "Preliminary results of the models testing for Mitochondrial Density"
#| label: results_preliminary_mitdensity
#
sum_mitdensity_prel <- m_prel_mit_density %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws()  %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_mitdensity_prel)
```

Model formula: mit_density ~ cort * temp + age + sex + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex or age, so they were discarded from the final models.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

Table S5.  Preliminary results of the models testing for Metabolic capacity.
```{r, results_preliminary_potential}
#| tbl-cap: "Preliminary results of the models testing for Metabolic capacity"
#| label: results_preliminary_potential
#
sum_potential_prel <- m_prel_mit_potential %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws() %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_potential_prel)
```

Model formula: mit_potential ~ cort * temp + age + sex + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex or age, so they were discarded from the final models.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

Table S6. Preliminary results of the models testing for ROS.
```{r, results_preliminary_ros}
#| tbl-cap: "Preliminary results of the models testing for ROS"
#| label: results_preliminary_ros
#
sum_m_ros_prel <- m_prel_ROS %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws() %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_m_ros_prel)
```

Model formula: ROS ~ cort * temp + age + sex + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex or age, so they were discarded from the final models.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

Table S7. Preliminary results of the models testing for DNA damage.
```{r, results_preliminary_dnadamage}
#| tbl-cap: "Preliminary results of the models testing for DNA damage"
#| label: results_preliminary_dnadamage
#
sum_m_dnadamage_prel <- m_prel_DNAdamage %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws() %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_m_dnadamage_prel)
```

Model formula: DNAdamage ~ cort * temp + age + sex + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex or age, so they were discarded from the final models.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

Table S8. Preliminary results of the models testing for lipid peroxidation.
```{r, results_preliminary_peroxidation}
#| tbl-cap: "Preliminary results of the models testing for lipid peroxidation"
#| label: results_preliminary_peroxidation
#
sum_m_peroxidation_prel <- m_prel_peroxidation %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws() %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_m_peroxidation_prel)
```

Model formula: peroxidation ~ cort * temp + age + sex + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex, so it was discarded from the final models. However, we saw an effect of age and we included it in our final models.

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```

Table S9. Preliminary results of the models testing for learning.
```{r, results_preliminary_learning}
#| tbl-cap: "Preliminary results of the models testing for lipid peroxidation"
#| label: results_preliminary_learning
#
sum_m_learn_prel <- m_prel_learn %>%
  dplyr::select(starts_with("b_")) %>%  # Removes random effect terms
  summarise_draws() %>%
  mutate(across(where(is.numeric), ~ as.numeric(format_dec(.x, 3))))
#
flextable(sum_m_learn_prel)
```

Model formula: errors ~ day * cort * temp + sex + age+ (1 + day | lizard_id) + (1|clutch).
Model convergence was checked through rhat and ess_bulk values. Summary indicates no effect of sex or age, so they were discarded from the final models.  

```{r, results='asis', echo=FALSE}
cat("\\newpage")
```


